- https://www.influxdata.com/graph-database/
- https://www.arangodb.com/graph-database/
	- Good illustrations
	- For each document, a unique  `_id`  attribute is stored automatically. To build a relation (i.e., an edge) between two documents (i.e., vertices), both  `_id`  attributes are stored in a special edge document known as  `_from`  and  `_to`  attributes, forming a directed connection between two arbitrary vertices. Edges are then stored in a special edge collection.
		- ![Graph Database](https://www.arangodb.com/wp-content/uploads/2020/01/image2.png){:height 175, :width 298}
	- Vertices and edges are both full JSON documents and can hold arbitrary data. By this approach combined with the edge index, ArangoDB is one of the few graph databases capable of horizontal scaling. Each edge and vertex can contain complex data in the form of nested propertiesю
	- So the simplest edge would be the line that connected you to a friend. However, what if this connection went one step further and described more things about your relationship? You could include details that are common among you, such as the fact that you both love Avocados (who doesn’t!?) and then when you wanted to find friends to join you for the Avocado Festival you could easily query that information. This would allow for things such as suggesting new friends, finding events based on you and your friends matching interests, or even recording important dates such as the date you became friends or other shared life events.
	- The details that make up the things you like, the things your friends like, and then the things that you share in common could be thought of as the properties of you and your friendships. This concept of modeling your data with descriptive labels is how data is modeled in a property graph. Property graphs use relevant semantic labels to model your data and its connections. This means that data can be structured in a way that is easily understood by a human.
- https://www.arangodb.com/2016/04/index-free-adjacency-hybrid-indexes-graph-databases/
	- The idea is that each node contains a list of pointers of its edges, therefore avoiding look-ups. In a distributed world, it’s clear that such a definition is meaningless, as the edges can live on different servers and there is no such thing as a “pointer” of an edge. In this case, all potential improvements discussed below are negligible in comparison to the communication latency, so much cleverer algorithms are needed in the distributed case.
	- The key message of index-free adjacency is, that the complexity to traverse the whole graph is O(n), where n is the number of nodes. In contrast, using any index will have complexity O(n log n). While this sounds plausible at first, it is simply wrong. Using a novel index, which combines hashes with linked-list, it is possible to gain the same complexity O(n) when traversing the whole graph. However, index-free adjacency has some severe pitfalls. It has drawbacks when there exist super-nodes. Access can be done fast, but deleting or modifying edges of such nodes becomes a nightmare. If you have a typical social network, then celebrities will have millions of followers. If you hit such a node, modifying operations suddenly become too complex to handle without indexes.
	- Can one do better? Yes, by using our novel hybrid index, one gets the best of both worlds. By combining a hash-index with a linked-list we were able to achieve the same access speed as an index-free implementation, while being way more efficient when deleting or modifying, especially when dealing with edges of super-nodes.
	- If you store the vertices at each node as list of direct pointers, then traversing all neighbors has complexity O(k), if a vertex has k edges. Note that this is the best possible complexity because O(k) is the size of the answer. Deleting a single edge also has the same complexity of O(k) (assuming a doubly linked list), which is much worse than optimal.
	- The choice of a hybrid index between hash and linked-list, solves this dilemma. We store all edges in a big hash table, and at the same time we put for each vertex V all those edges that are incident with V into a doubly linked list.
		- ![ArangoDB_Hybrid_Hash_Linked-List_Index](https://www.arangodb.com/wp-content/uploads/2016/02/ArangoDB_Hybrid_Hash_Linked-List_Index-1024x569.png)
	- This allows to proceed as follows: Finding the starting point for the linked list of a vertex is a single hash lookup by the vertex key, which is O(1) with a very good constant. If a vertex has k neighbors, traversing all its neighbors has complexity O(k) because of the linked-list aspect of the index, we simply have to run through the linked list once we have found the start in O(1), but O(1) + O(k) = O(k). For single-edge modifications and single-edge deletions we first look up by the vertex key, in case the edge is the first in the linked list of the vertex, and if this fails to find the edge, we do one further lookup to find the edge by its own key. Thus, we can find the edge in O(1) and then modify or delete it. This is only possible, because the edge index is both a big hash table for all edges and a linked list for each vertex’s neighbours. Overall, the complexity is now O(k) for neighbors – as good as theoretically possible – and O(1) for single-edge modifications – again the best possible result.
	- On the other hand, if you have a large graph that does not completely fit into memory, a drawback of index-free adjacency becomes apparent. If you look at the iconic graph query, namely a pattern matching in a large graph, an index might even be faster, because you do not need to look at these vertices at all. You only need the index itself, which is much smaller than the complete node data. Therefore it is much more memory and cache friendly, which is of most importance with nowadays’ technology.
- http://tomheath.com/slides/2009-02-austin-linkeddata-tutorial.pdf
	- **Triples** in RDF, Resource Description Framework
		- subject → predicate → object
		- Tom -> worksFor -> Talis
		- Talis -> basedIn -> Birmingham
		- [uri] → [uri] → [uri] or "literal"
	- Linked Data Principles
		- Use URIs as names for things
		  – anything, not just documents
		  – you are not your homepage
		  – information resources and non-information resources
		- Use HTTP URIs
		  – globally unique names, distributed ownership
		  – allows people to look up those names
		- Provide useful information in RDF
		  – when someone looks up a URI
		- Include RDF links to other URIs
		  – to enable discovery of related information
- https://medium.com/@eisenzopf/graph-databases-linked-data-rdf-and-the-semantic-web-wasteland-69e9f4347a5b
	- Google has adopted a semantic markup scheme called [JSON-LD](http://json-ld.org/). If you’ve read this far you already know what JSON is. JSON-LD allows developers and designers to add semantic meaning to web content using a JSON wrapper. It looks a bit like this (from JSON-LD.org):
		- ```
		  {
		  "@context": "[http://json-ld.org/contexts/person.jsonld](http://json-ld.org/contexts/person.jsonld)",
		  "@id": "[http://dbpedia.org/resource/John_Lennon](http://dbpedia.org/resource/John_Lennon)",
		  "name": "John Lennon",
		  "born": "1940-10-09",
		  "spouse": "[http://dbpedia.org/resource/Cynthia_Lennon](http://dbpedia.org/resource/Cynthia_Lennon)"
		  }
		  ```
- https://tdan.com/tales-tips-from-the-trenches-two-types-of-graph-databases/25989#
	- ### Property Graph Database
	- ![](https://tdan.com/wp-content/uploads/2020/02/Screen-Shot-2020-02-02-at-12.35.38-PM.png)
	- The edges are labeled
	- Both vertices and edges can have any number of key/value properties associated with them
	- Graph databases are more complex compared to the standard single-relational graphs
	  
	  #+BEGIN_EXPORT hiccup
	  [:figure {} [:a {:href "https://tdan.com/wp-content/uploads/2020/02/Screen-Shot-2020-02-02-at-12.35.38-PM.png"} [:img {:src "https://tdan.com/wp-content/uploads/2020/02/Screen-Shot-2020-02-02-at-12.35.38-PM.png", :alt "", :srcset "https://tdan.com/wp-content/uploads/2020/02/Screen-Shot-2020-02-02-at-12.35.38-PM.png 948w, https://tdan.com/wp-content/uploads/2020/02/Screen-Shot-2020-02-02-at-12.35.38-PM-768x358.png 768w", :sizes "(max-width: 948px) 100vw, 948px"}]] [:figcaption {} "Figure 1 illustrates a property graph with two vertices and one edge."]]
	  #+END_EXPORT
	  
	  Each node represents a single person who is connected with others through relationships. Figure 1 shows:
	- John works with Jane since year 2000.
	- ### Semantic Graph Database
		- ![](https://tdan.com/wp-content/uploads/2020/02/Screen-Shot-2020-02-02-at-12.35.47-PM.png)
		- It is made up of semantic triples in the form of **Subject-Predicate-Object.**
		- It is capable of integrating heterogeneous data from many sources.
		- It is a type of NoSQL graph database.
		  
		  #+BEGIN_EXPORT hiccup
		  [:figure {} [:a {:href "https://tdan.com/wp-content/uploads/2020/02/Screen-Shot-2020-02-02-at-12.35.47-PM.png"} [:img {:src "https://tdan.com/wp-content/uploads/2020/02/Screen-Shot-2020-02-02-at-12.35.47-PM.png", :alt "", :srcset "https://tdan.com/wp-content/uploads/2020/02/Screen-Shot-2020-02-02-at-12.35.47-PM.png 1684w, https://tdan.com/wp-content/uploads/2020/02/Screen-Shot-2020-02-02-at-12.35.47-PM-768x307.png 768w", :sizes "(max-width: 1684px) 100vw, 1684px"}]] [:figcaption {} "Figure 2 illustrates a semantic graph integrating heterogeneous data from many sources and making links between datasets."]]
		  #+END_EXPORT
- https://www.codeproject.com/Articles/832959/Semantic-Database-Concept-Architecture-and-Impleme
	- **Semantics** is the study of **meaning**
	- It focuses on the relationship between:
		- **Signifiers**: words, phrases, signs and symbols
		- **Denotation**: what they stand for
	- This problem stems partially from the fact that a graph database represents a specific domain: *"By assembling the simple abstractions of nodes and relationships into connected structures, graph databases enable us to build arbitrarily sophisticated models that map closely to our problem domain."* - (ibid, pg 6).
	- At best, we can say a node with properties "firstname" and "lastname" represents a "person", but we can say nothing else about that person, such as distinguishing the person from the playwright, the producer, or the actor, *except* through a relationship with another concrete node, where the relationship provides further semantic meaning, such as "wrote_play", or "produced_play" or "acted_in".
	- Advantages
		- By preserving semantic structure, we can query the database at different levels of semantic meaning, from very specific to very general.
		- For example, the semantic type “Title” is very general but allows us to ask “what are all the values of things having the meaning “Title”?
		- By inspecting the relationships, we can ask “what are the things having “Title” in their meaning?
		- When we query the database, we don’t just get back a list of records – we get back fully “rehydrated” semantic types.
	- Drawbacks
		-