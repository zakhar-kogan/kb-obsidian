- [[associative data]] [[graphs]]
- https://iacis.org/iis/2009/P2009_1301.pdf
	- Two of the relatively well-known database models are the ==hierarchical and network models.== Hierarchical models involve “a data structure in which the elements of the structure have only one-to-many relationships with one another”
		- ![image.png](../assets/image_1668714435236_0.png)
	- Similarly, Kroenke [11] defines a network database structure is one “in which at least one of the
	  relationships is many-to-many.”
		- ![image.png](../assets/image_1668714473250_0.png)
	- One of the most commonly used database structures is the ==relational database model==. As the name implies the relational database model “has the relation at its heart, but then a whole series of rules governing keys, relationships, joins, functional dependencies, transitive dependencies, multi-valued dependencies, and modification anomalies” [14 The Relational Data Model, para. 1].
		- ![image.png](../assets/image_1668714513811_0.png)
		- ![image.png](../assets/image_1668714526333_0.png)
	- Normalization is a major challenge in RDBMS design. Kroenke [10] defines normalization as “a
	  process for converting a relation that has certain problems to two or more relations that do not have these problems.” Much is written about tips for normalizing a database and many authors note that an RDBMS is not the best database design for all types of data. Even in more recent writings by the father of the RDBMS, Codd [5] admits that a “relational database is best suited to data with a rather regular or homogeneous structure” and that more research is needed to determine if an RDBMS can sufficiently handle “heterogeneous data” such as “images, text, and miscellaneous facts.”
	- The ==associative database model== is claimed to offer advantages over RDBMS and other database models. While an RDBMS and other database models are record-based – with data stored in rows and columns in tabular representations shown in figures 4 and 5 – all data in the associative database model is modeled as discrete independent data elements.
	- Relationships between data elements are modeled as **associations**. Griffiths [7] describes these *“two fundamental data structures” as “„**Items**‟ and a set of „**Links**‟ that connect them together.”* Williams [17] introduces the associative database model as having two types of data structures, Items which have *“a unique identifier, a name and a type”* and Links which have *“a unique identifier, together with the unique identifiers of three other things, that represent the source, verb and target of a fact that is recorded about the source in the database.”* He further notes that *“each of the three things identified by the source, verb and target may each be either a link or an item.”*
		- ![image.png](../assets/image_1668716278247_0.png)
	- ![image.png](../assets/image_1668716319666_0.png)
	- ADBMS that may make it more attractive to future users is its inherent security features. The content (data) and index (associations) can be stored together or separately in different places. If a hacker were to access one or the other, Aysola [1] notes that “nothing more than an unlimited character string” is revealed.
- https://web.archive.org/web/20220518204118/https://link.springer.com/content/pdf/10.1057/palgrave.jdm.3240049.pdf
	- Brains do not need new thought
	  processes to think about new things —
	  why do computers? Every new relational
	  application needs a new set of programs
	  developed from scratch, because a
	  program written to use one set of tables
	  cannot be reused with a different set.
	  This creates a need for a never-ending
	  supply of new programs, the
	  development and maintenance of which
	  is labour-intensive, expensive and
	  wasteful
	- Users do not all need the same
	  functions — why is customisation so
	  difficult? Relational applications offered
	  by ASPs (Application Service Providers)
	  and package vendors can only be tailored
	  to the needs of large numbers of
	  individual users through complex
	  parameterisation or through customisation
	  which renders subsequent upgrades more
	  difficult. Finding a way to support the
	  customisation of applications for
	  individual users is one of the main challenges faced by early players in the
	  burgeoning ASP marketplace.
	- All customers are not the same —
	  why store the same information about
	  each one? Relational applications cannot
	  record a piece of information about an
	  individual thing that is not relevant to
	  every other thing of the same type.
	  Consequently, applications have to store
	  the same information about every
	  customer, order, product and so on. This
	  limits marketers’ ability to continually
	  improve the quality of customer service,
	  because applications cannot record and
	  take account of the needs of individual
	  customers.
	- All databases store data — why can
	  they not work together more easily?
	  Information about identical things in the
	  real world is structured differently in
	  every relational database, so it is difficult
	  and expensive to amalgamate two
	  databases. The cost of integrating systems
	  is now a major impediment to mergers
	  and acquisitions. Extracting useful
	  information from across several databases
	  demands expensive data warehousing and
	  mining projects.
	- It is no longer necessary to write every
	  new application from scratch. The same
	  set of programs can be used to
	  implement many different associative
	  applications without being altered or
	  rewritten in any way, allowing users to
	  create new applications from existing
	  ones. The saving in software
	  development costs afforded by this
	  capability will be substantial.
	  Applications can be tailored for
	  individual users. Associative applications
	  can permit features to be used or ignored
	  selectively by individual users without
	  the need for parameterisation or customisation. Data sets can be similarly
	  partitioned with precise granularity, to be
	  visible or invisible to individual users.
	  This approach is ideally suited to the
	  needs of ASPs and application package
	  vendors alike.
	  The information needed about each
	  customer can be stored precisely. An
	  associative database can record
	  information that is relevant only to one
	  thing of a particular type, without
	  demanding that it be relevant to all other
	  things of the same type. With this
	  capability, we can continue to enhance
	  the quality of customer service and hone
	  competitive edge.
	  Databases can be integrated without
	  extra programming or data warehousing
	  tools. Separate associative databases can
	  be readily correlated or merged without
	  extra programming, and multiple
	  databases distributed across many servers
	  can be accessed by applications as though
	  they were a single database. These
	  capabilities significantly reduce the cost
	  of amalgamating databases, and allow
	  information to be readily extracted from
	  across multiple databases without the
	  need for data warehousing.
	- Many people who hear the term
	  ‘relational’ for the first time assume that it
	  derives from relationships between the
	  things stored in the database. In fact, it
	  comes from the mathematical concept of
	  a ‘relation’: ‘Given sets S1, S2, . . ., Sn, R
	  is a relation on these n sets if it is a set of
	  n-tuples, the first component of which is
	  drawn from S1, the second component
	  from S2, and so on’. The proper term for
	  the tables described here is ‘relations’.
	- Every new relational database application needs a new set of programs
	  written from scratch, because a program
	  written for one application cannot be
	  reused for another. This creates a need for
	  a never-ending supply of new programs,
	  the development of which is
	  labour-intensive, time-consuming and
	  expensive. Why is this so?
	  Programs are designed around tables.
	  Under the relational model, every table
	  is structured differently — that is, it has
	  different columns and column headings
	  — and the programs are designed around
	  the tables. It is impossible to write an
	  efficient program that is capable of
	  accessing a table whose structure is not
	  known when the program is written, just
	  as it is impossible to make a key that
	  will open any lock. Every program has
	  to be written by someone with precise
	  knowledge of the tables that it will use,
	  and a program that uses one set of tables
	  cannot be used with a different set. In
	  commercial applications, each entity type
	  — customers, products, orders and so on
	  — is represented by at least one table,
	  and most applications involve between
	  50 and 500 entity types, so each new
	  application needs somewhere between
	  500 and 5,000 new programs to be written from scratch.
	- One of the stated goals of
	  object-oriented programming was the
	  re-use of program code. Some 20 years
	  after the first object-oriented languages
	  were developed, however, almost no true
	  re-use has been achieved. Some
	  development tools automate the process
	  of writing programs by re-using program
	  designs, but such tools demand higher
	  levels of skill and training and thus
	  greater up-front investment than
	  traditional programming techniques, so
	  despite their impressive productivity
	  levels their use is not widespread. Most
	  programs developed today are still
	  hand-coded from scratch in a highly
	  labour-intensive manner. Re-use has
	  failed not because programming
	  languages and tools are deficient or
	  because programmers are not clever
	  enough, but simply because data are not
	  stored in a way that permits it
	- Parameterisation fuels complexity.
	  Historically, the behaviour of each
	  installation of an application package has
	  been determined by parameterisation: the application checks a set of parameter
	  values as it executes to determine
	  precisely how its code should behave.
	  This approach has drawbacks arising
	  from the exponential increase in
	  complexity as new options are added
	  over time. The code itself becomes
	  extremely complex: different pieces of
	  business logic need to check different
	  parameters to determine whether they
	  are invoked, and as the number of
	  options increases, new functions are
	  more difficult to add, and testing the full
	  range of configurations created by
	  different combinations of parameters
	  becomes more difficult. Also, deploying
	  the package becomes very costly for
	  customers. The lion’s share of the cost of
	  installing a sophisticated package goes on
	  the specialist assistance needed to
	  implement it. A major component of
	  this is the time and know-how involved
	  in setting up the package to achieve the
	  desired behaviour.
	- Modified packages are difficult to
	  upgrade to new releases. Users who
	  require functionality not provided by the
	  core package must modify their copy to
	  create the behaviour that they require.
	  This greatly increases the difficulty of
	  upgrading to new versions of the
	  package provided by the vendor, which
	  often contain important new
	  functionality that the customer would
	  wish to exploit. A small industry of
	  source code comparison, configuration
	  management and impact analysis skills
	  and tools exists to cater for precisely this
	  need, but even so, typically fewer than
	  50 per cent of major application package
	  users implement new releases for this
	  reason.
	- Every column of every row must be
	  occupied. The relational model dictates
	  that every row must have a value in
	  every column. If the value is unknown,
	  the column must contain a special mark
	  called a ‘null’. For a relation to store a
	  piece of information that relates to only
	  one row, an entire column in every
	  single row would be have to be set aside
	  to cater for it, and the empty column in
	  every other row would have to contain a
	  null. In commercial applications, it is not
	  unusual for a relation to contain many
	  thousands or even millions of rows. If a
	  customer table contained 10,000
	  customers, setting aside a column to
	  record a piece of information unique to
	  one customer would entail storing 9,999
	  nulls. To store information unique to just
	  10 per cent of customers would add
	  1,000 columns to the table, and entail
	  storing almost 10m nulls. The overhead
	  of storage space and processing time to
	  do this renders it impractical.
	- It is impractical to merge tables from
	  two databases. The simplest case involves
	  two tables that perform the same
	  function: such as the two customer
	  tables. The rows cannot simply be added
	  from one customer table to the other,
	  because every row in a relation must
	  have the same columns, and inevitably
	  there will be at least one pair of columns
	  that do not match. So both tables have
	  to be examined and the corresponding
	  columns matched up. Even when
	  columns whose functions match are
	  found, often they will contain different
	  types of data: one designer may have
	  chosen to identify customers by a
	  number, and the other by a code using
	  both letters and numbers. One must be
	  chosen, new values assigned to the other,
	  and then trawled the entire database
	  through replacing old values with new ones. All this work deals with just one
	  column in one pair of matching tables,
	  but the nature of the relational database
	  design process means that many of the
	  tables in one database will have no direct
	  equivalent in the other, so the process
	  just described will often be the tip of the
	  iceberg. Even when marketers stop short
	  of merging databases — perhaps only a
	  simple question needs answering, such as
	  how many customers the two subsidiaries
	  share in common — marketers have to
	  go through this cross-referencing exercise
	  before they can begin to find the answer
	  to the question.
	- Bank accounts are object-oriented. A
	  bank account is a good analogy for an
	  object. A bank customer cannot change
	  anything about their bank account
	  directly: instead they send it messages in
	  the form of cheques, deposits, balance
	  inquiries and so on. A bank account’s
	  methods are ‘pay a cheque’, ‘receive a
	  deposit’, ‘produce a statement’ and so
	  on. A particular bank account is an
	  instance of the class ‘bank account’
	- Object orientation
	  is first and foremost a better way to
	  write programs. In the context of
	  transaction processing, object databases
	  are burdened with some irrelevant
	  concepts. One such is encapsulation,
	  whereby each data item is in the
	  protective custody of an object and may
	  be changed only by submitting a
	  procedural request to that object. This is
	  a good way to ensure the integrity of
	  variables in a multitasking environment,
	  but it is irrelevant to a general ledger
	  table containing several million rows of
	  data, and it makes the process of
	  querying data more cumbersome and
	  inefficient than it need otherwise be
	- Real-world things are entities or
	  associations. The associative model
	  divides the real-world things about
	  which data is to be recorded into two
	  sorts:
		- entities are things that have discrete,
		  independent existence. An entity’s existence does not depend on any
		  other thing
		- associations are things whose existence
		  depends on one or more other things,
		  such that if any of those things ceases
		  to exist, then the thing itself ceases to
		  exist or becomes meaningless.
	- Examples
		- — a person is an entity, while a person’s
		  roles as a customer, an employee, a
		  spouse, a salesperson, a shareholder, a
		  team member and so on are
		  associations
		- — an enterprise is an entity, while an
		  enterprise’s roles as a customer, a
		  supplier, a contractual party, a tenant,
		  and so on are associations
		- — a consumer good, such as a car or a
		  television, is an entity, while its
		  various roles as the end product of a
		  manufacturing process, a production
		  schedule line item, the subject of a
		  warranty agreement, and so on are
		  associations
		- — a building is an entity, while its
		  various roles as a corporate
		  headquarters, a workplace, the
		  location of assets are associations.
	- An association may depend upon another
	  association: for example, a sales order
	  may depend on a customer, which is
	  itself an association. Similarly each line of
	  a sales order depends on the sales order
	  itself
	- ![image.png](../assets/image_1668719177256_0.png)
	- By
	  classifying real-world things as entities
	  and associations, the associative model
	  separates two ideas: on one hand, the
	  idea of something that has discrete,
	  independent existence, and on the other
	  hand the idea of the various ways in
	  which such a thing interacts with other
	  things. Each such interaction is a thing
	  in its own right, about which marketers
	  may want to record information. A
	  real-world association is represented as an
	  association between two other things,
	  each of which might itself be an entity
	  or an association.
	- The associative model distinguishes
	  entities and associations for a simple and
	  fundamentally important reason: data
	  models constructed by following this
	  principle are closer to reality, and thus
	  easier to comprehend, better able to
	  respond to change, and better able to
	  integrate readily with other data models.
	  Such data models will serve users better
	  and prove more cost-effective, in both
	  the short term and, more importantly,
	  over the long term.
	- Specifically,
	  the relational model does not distinguish
	  entities and associations, on the grounds
	  that both entities and associations have,
	  in Codd’s words, immediate properties.
	- Items and links
	- An associative database comprises two
	  data structures:
		- set of items, each of which has a
		  unique identifier, a name and a type.
		- a set of links, each of which has a
		  unique identifier, together with the
		  unique identifiers of three other
		  things, that represent the source, verb
		  and target of a fact that is recorded
		  about the source in the database. Each of the three things identified by the
		  source, verb and target may be either
		  a link or an item.
	- ![image.png](../assets/image_1668719304677_0.png)
	- How the associative model would use
	  these two structures to store the piece of
	  information ‘Flight BA1234 arrived at
	  London Heathrow on 12-Dec-98 at
	  10:25am’ is now described. There are
	  seven items: the four things ‘Flight
	  BA1234’, ‘London Heathrow’,
	  ‘12-Dec-98’ and ‘10:24am’, and the
	  three verbs ‘arrived at’, ‘on’ and ‘at’.
	  Three links are needed to store the data.
	  They are:
	  Flight BA1234 arrived at Heathrow
	  Airport
	  . . . on 12-Aug-98
	  . . . at 10:25am
	  Each line is one link. The first link uses
	  ‘arrived at’ to associate ‘Flight BA1234’
	  and ‘Heathrow Airport’. The second link
	  uses ‘on’ to associate the first link and
	  ‘12-Aug-98’. (A link that begins with an
	  ellipsis ‘...’ has the previous link as its
	  source.) The third link uses ‘at’ to
	  associate the second link and ‘10:25am’.
	- When writing links, instead of using
	  new lines to show each link, sometimes it is more convenient to keep going in a
	  long string. When this is done, brackets
	  are put around each link. Written this
	  way, the example would look like this:
	  ((Flight BA1234 arrived at Heathrow
	  Airport) on 12-Aug-98) at 10:25am
	- ![image.png](../assets/image_1668719595968_0.png)
	- ![image.png](../assets/image_1668719605696_0.png)
	- ![image.png](../assets/image_1668719621305_0.png)
	- ![image.png](../assets/image_1668719635584_0.png)
	- ![image.png](../assets/image_1668719668621_0.png)
	-